---
title: "models_datasources"
author: "Aimara Planillo"
date: "2023-05-30"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# Run models for the different datasets


```{r}
source("./Rscripts/source_file_packages.R")

workDir <- getwd()
dataproc_wd <- paste0(workDir, "/output/data_proc")
geoproc_wd <- paste0(workDir, "/output/geo_proc")
results_wd <- paste0(workDir, "/output/results")

# change java memory use in windows to 8gb so the maxent models can be run
# options(java.parameters = "-Xmx8000m")
```




# GLMM model

we use data **before 2018**
- presences: telemetry data filtered by day and grid
- background: random points (10x presences) selected in 100% MCPs, filtered by grid
- environmental variables extracted at the point location
- Data divide into train (80%) and test (20%) sets


Load data
```{r}
# Load observations with env data
pres_gps_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_pres_telemetry.gpkg")) %>% 
  st_transform(crs = 3035)  
  
# Load background with env data
bg_mcp_glmm_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_bg_mcp_glmm.gpkg")) %>% 
  st_transform(crs = 3035)

# put both dataset together and select training data
pres_gps_envcov_tmp <- pres_gps_envcov_sf %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(id, point_case, type, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

bg_mcp_glmm_envcov_tmp <- bg_mcp_glmm_envcov_sf %>% 
  mutate(point_case = 0) %>% 
  dplyr::select(id, point_case, type, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

train_glmm_envcov_tmp <- rbind(pres_gps_envcov_tmp, bg_mcp_glmm_envcov_tmp) %>% 
  filter(type == "train")
summary(train_glmm_envcov_tmp)

test_glmm_envcov_tmp <- rbind(pres_gps_envcov_tmp, bg_mcp_glmm_envcov_tmp) %>% 
  filter(type == "test")
```

prepare train and test data for glmm 

```{r}
# TRAIN DATA
train_glmm_envcov_df <- train_glmm_envcov_tmp %>% 
  mutate(x_3035 = st_coordinates(.)[,1], 
         y_3035 = st_coordinates(.)[,2]) %>% 
  as.data.frame() %>% 
  mutate(weighting = ifelse(point_case == 1, 10, 1),
         CLC2012 = as.factor(as.character(CLC2012))) %>% 
  droplevels() %>% 
  dplyr::select( -geom)
  
table(train_glmm_envcov_df$CLC2012)

# No observations in clc 103, we remove the level 
my_glmm_data <- train_glmm_envcov_df[train_glmm_envcov_df$CLC2012 != 103, ] %>% 
  droplevels()

my_glmm_data$CLC2012

my_glmm_data <- na.omit(my_glmm_data)
head(my_glmm_data)


# TEST DATA
# remove the extra Land use
my_glmm_test_data <- test_glmm_envcov_tmp %>% 
  mutate(x_3035 = st_coordinates(.)[,1], 
         y_3035 = st_coordinates(.)[,2]) %>% 
  as.data.frame() %>% 
  mutate(weighting = ifelse(point_case == 1, 10, 1),
         CLC2012 = as.factor(as.character(CLC2012))) %>% 
  filter(CLC2012 != "103") %>% 
  droplevels() %>% 
  dplyr::select(-geom)

my_glmm_test_data$CLC2012
table(my_glmm_test_data$CLC2012)

my_glmm_test_data <- na.omit(my_glmm_test_data)
head(my_glmm_test_data)

# write.csv(my_glmm_data, paste0(results_wd, "/glmm_results/glmm_train_data.csv"), row.names = FALSE)
# write.csv(my_glmm_test_data, paste0(results_wd, "/glmm_results/glmm_test_data.csv"), row.names = FALSE)
```

Put toghether datasets and save to data folder without coordinates
```{r}
glmm_data_bf2018 <- rbind(my_glmm_data, my_glmm_test_data) %>% 
  dplyr::select(-c(x_3035, y_3035))

head(glmm_data_bf2018)

write.csv(glmm_data_bf2018)
```

## Run glmm
```{r}
glmm_linear <- glmer(point_case  ~ 
                   CLC2012 * 
                    (scale(HFP) + 
                       scale(Pop_den) + 
                       scale(Dist_settl) + 
                       scale(Dist_roads)) + 
                    (1|id), 
                  family = binomial(), 
                  weights = weighting, 
                  data = my_glmm_data, 
                  verbose = FALSE, 
                  nAGQ = 0, 
                  control = glmerControl(optimizer = "nloptwrap"),
                  na.action = na.fail
                  )

summary(glmm_linear)

## see effects
ggpredict(glmm_linear, terms = c("HFP [all]", "CLC2012")) %>%
    plot() +
    xlab("HFP") +
    scale_colour_manual(values = viridis(7),
                      name = "CLC",
                      labels = c("urban", "agriculture", "forest",
                                               "green no cover", "green with cover",
                                               "soil no cover", "water bodies")) +
    theme(panel.background = element_blank()) 

ggpredict(glmm_linear, terms = c("Pop_den [all]", "CLC2012")) %>%
    plot() +
    xlab("Pop_den") +
    scale_colour_manual(values = viridis(7),
                      name = "CLC",
                      labels = c("urban", "agriculture", "forest",
                                               "green no cover", "green with cover",
                                               "soil no cover", "water bodies")) +
    theme(panel.background = element_blank()) 

ggpredict(glmm_linear, terms = c("Dist_settl [all]", "CLC2012")) %>%
    plot() +
    xlab("Dist_settl") +
    scale_colour_manual(values = viridis(7),
                      name = "CLC",
                      labels = c("urban", "agriculture", "forest",
                                               "green no cover", "green with cover",
                                               "soil no cover", "water bodies")) +
    theme(panel.background = element_blank()) 

ggpredict(glmm_linear, terms = c("Dist_roads [all]", "CLC2012")) %>%
    plot() +
    xlab("Dist_roads") +
    scale_colour_manual(values = viridis(7),
                      name = "CLC",
                      labels = c("urban", "agriculture", "forest",
                                               "green no cover", "green with cover",
                                               "soil no cover", "water bodies")) +
    theme(panel.background = element_blank()) 

# model assumptions (DHARMa)
simulationOutput <- simulateResiduals(fittedModel = glmm_linear, plot = T)

testZeroInflation(simulationOutput)
testDispersion(simulationOutput)
residuals(simulationOutput)
plot(simulationOutput)


## rerun GLMM model

# account for overdispersion 
my_glmm_data$obs <- 1:nrow(my_glmm_data)
glmm_linear2 <- glmer(point_case  ~ 
                   CLC2012 * 
                    (scale(HFP) + 
                       scale(Pop_den) + 
                       scale(Dist_settl) + 
                       scale(Dist_roads)) + 
                    (1|id), 
                  family = binomial(), 
                  # weights = weighting,
                  data = my_glmm_data, 
                  verbose = FALSE, 
                  nAGQ = 0, 
                  control = glmerControl(optimizer = "nloptwrap"),
                  na.action = na.fail
                  )
simulationOutput2 <- simulateResiduals(fittedModel = glmm_linear2, plot = T)

anova(glmm_linear, glmm_linear2)

testDispersion(simulationOutput2)
residuals(simulationOutput2)
plot(simulationOutput2)


# preudo r square
# r.squaredGLMM(glmm_full)
r.squaredGLMM(glmm_linear2)
```

## GLMM predict
```{r}
## load rasters
env_germany <- stack(paste0(geoproc_wd, "/stack_env_rasters_germany_3035_AP.tif"))
# add names to the stack
names(env_germany) <- c("CLC2012", "Pop_den", "Dist_settl", "Dist_roads", "HFP") 


f <- list(levels(my_glmm_data$CLC2012))
names(f) <- "CLC2012"

pred_glmm_linear <- raster::predict(object =  env_germany, 
                                    model= glmm_linear2, 
                                    re.form = ~ 0, 
                                    type = c("response"),
                                    factors = f)

values(pred_glmm_linear)

## plot predictions
plot(pred_glmm_linear) 
tm_glmm <- tm_shape(pred_glmm_linear) + 
  tm_raster(alpha = 1,
            n = 10, 
            palette = viridis(100), 
            legend.show = TRUE,
            title = "GLMM predictions") +
   tm_layout(title = paste0("GLMM"),
              title.color = "black",
              title.bg.color = "white",
              title.position = c(0.001, 0.95), 
              legend.position = c(0.75, 0.7),
              legend.bg.color = NA,
              frame = FALSE,
              legend.show = TRUE,
              inner.margins = c(0, 0, 0.05, 0.2),
              outer.margins = c(0, 0, 0, 0)) +
     tm_scale_bar(breaks = c(0, 100, 200), 
                  text.size = 1, 
                  position = c(0.68,0.05))
```

## Model evaluation

```{r}
# AUC test
linear_eval2 <- dismo::evaluate(p = my_glmm_test_data[my_glmm_test_data$point_case == 1,], 
                a = my_glmm_test_data[my_glmm_test_data$point_case == 0,], 
                model = glmm_linear2)

linear_eval <- dismo::evaluate(p = my_glmm_test_data[my_glmm_test_data$point_case == 1,], 
                a = my_glmm_test_data[my_glmm_test_data$point_case == 0,], 
                model = glmm_linear)

linear_eval
linear_eval@auc
# [1] 0.7286928

plot(linear_eval, 'ROC')
plot(linear_eval, 'kappa')
plot(linear_eval, 'FPR')
plot(linear_eval, 'prevalence')
boxplot(linear_eval)
density(linear_eval)


# TSS test 
# Threshold for TSS: MaxSSS threshold

# Predict test data
sp_pred <- predict(glmm_linear2, my_glmm_test_data)
sp_occ <- my_glmm_test_data$point_case

TSS100_glmm_test <- ecospat.max.tss(Pred = sp_pred, Sp.occ = sp_occ) # tss along multiple thresholds
TSS100_table <- TSS100_glmm_test$table
TSS100_table[TSS100_table$threshold== TSS100_glmm_test$max.threshold,] # tss in MaxSSS threshold

test_presences <- my_glmm_test_data %>% 
  filter(point_case == 1) %>%  # only presences
  st_as_sf(coords = c("x_3035", "y_3035"), crs = 3035) #make spatial

test_presences_xy <- st_coordinates(test_presences)  


presences_predict_values <- cbind.data.frame(sp_pred, sp_occ) %>% 
  filter(sp_occ == 1)

# get habitat suitability values (raster values) for test presences
pred_values_test <- raster::extract(pred_glmm_linear, as_Spatial(test_presences), sp = TRUE)
pred_values_test_vector <- pred_values_test$pred_glmm_linear_20210306
# [1] 643

# with spatial data
test_sp <- ecospat.boyce(fit = pred_glmm_linear, obs = test_presences_xy, nclass = 0)
test_sp$Spearman.cor
# [1] 0.998

```


## GLMM validation - test set 2 - >=2018 data

```{r load and prepare data}
#load test2 data with env values
obs_mcp_glmm_test2_af2018 <- st_read(paste0(dataproc_wd, "/envcov_pres_telemetry_af2018.gpkg"))
obs_mcp_glmm_test2_af2018_df <- st_coordinates(obs_mcp_glmm_test2_af2018)
unique(obs_mcp_glmm_test2_af2018$id)

bg_mcp_glmm_test2_af2018 <- st_read(paste0(dataproc_wd,"/envcov_bg_mcp_glmm_af2018.gpkg"))
bg_mcp_glmm_test2_af2018_df <- st_coordinates(bg_mcp_glmm_test2_af2018)

obs_test2_mcp_glmm_envcov_tmp <- obs_mcp_glmm_test2_af2018 %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(id, point_case, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

bg_test2_mcp_glmm_envcov_tmp <- bg_mcp_glmm_test2_af2018 %>% 
  mutate(point_case = 0) %>% 
  dplyr::select(id, point_case, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

test2_glmm_envcov_tmp <- rbind(obs_test2_mcp_glmm_envcov_tmp, bg_test2_mcp_glmm_envcov_tmp) 
summary(test2_glmm_envcov_tmp)

# remove the extra Land use
# TEST DATA
my_glmm_test2_data <- test2_glmm_envcov_tmp %>% 
  mutate(x_3035 = st_coordinates(.)[,1], 
         y_3035 = st_coordinates(.)[,2]) %>% 
  as.data.frame() %>% 
  mutate(weighting = ifelse(point_case == 1, 10, 1),
         CLC2012 = as.factor(as.character(CLC2012))) %>% 
  filter(CLC2012 != "103") %>% 
  droplevels() %>% 
  dplyr::select(-geom)

my_glmm_test2_data <- na.omit(my_glmm_test2_data)
head(my_glmm_test2_data)
my_glmm_test2_data %>% 
  group_by(point_case) %>% 
  summarise(nrows = n())

pres2 <- my_glmm_test2_data[my_glmm_test2_data$point_case == 1,]
abs2 <- my_glmm_test2_data[my_glmm_test2_data$point_case == 0,]
str(pres2)
str(abs2)
```


```{r model validation}
# AUC test
linear_eval2 <- dismo::evaluate(p = my_glmm_test2_data[my_glmm_test2_data$point_case == 1,], 
                a = my_glmm_test2_data[my_glmm_test2_data$point_case == 0,], 
                model = glmm_linear2, allow.new.levels = TRUE) # this is necessary for the new random factors
linear_eval2@auc

linear_eval <- dismo::evaluate(p = my_glmm_test2_data[my_glmm_test2_data$point_case == 1,], 
                a = my_glmm_test2_data[my_glmm_test2_data$point_case == 0,], 
                model = glmm_linear, allow.new.levels = TRUE) # this is necessary for the new random factors

linear_eval
linear_eval@auc


# TSS test 
# Threshold for TSS: MaxSSS threshold

# Predict test data
sp_pred2 <- predict(glmm_linear2, my_glmm_test2_data, allow.new.levels = TRUE)
sp_occ2 <- my_glmm_test2_data$point_case

TSS100_glmm_test2 <- ecospat.max.tss(Pred = sp_pred2, Sp.occ = sp_occ2) # tss along multiple thresholds
TSS100_test2_table <- TSS100_glmm_test2$table
TSS100_test2_table[TSS100_test2_table$threshold== TSS100_glmm_test2$max.threshold,] # tss in MaxSSS threshold


# continuous Boyce index (library: ecospat)
## Requires the Habitat suitabilty predictions

test2_presences <- my_glmm_test2_data %>% 
  filter(point_case == 1) %>%  # only presences
  st_as_sf(coords = c("x_3035", "y_3035"), crs = 3035) #make spatial

test2_presences_xy <- st_coordinates(test2_presences)  

presences2_predict_values <- cbind.data.frame(sp_pred2, sp_occ2) %>% 
  filter(sp_occ2 == 1)

# get habitat suitability values (raster values) for test presences
pred_glmm_linear_values <- values(pred_glmm_linear) 
pred_glmm_linear_values <- pred_glmm_linear_values[!is.na(pred_glmm_linear_values)]

pred_values_test <- raster::extract(pred_glmm_linear, as_Spatial(test2_presences), sp = TRUE)
pred_values_test_vector <- pred_values_test$pred_glmm_linear_20210306

# with vector data
test2_boyce_glmm <- ecospat.boyce(fit = pred_glmm_linear_values, obs = pred_values_test_vector, 
                                  nclass = 0)
test2_boyce_glmm$Spearman.cor
```


## GET GLMM individual random effects
```{r}
## Load model
my_colors <- viridis(18)

glmm_linear2@call

pr <- ggpredict(glmm_linear2, terms = c("CLC2012", "id"), type = "re")

# plot together
(my_plot_1 <- plot(pr) +
  scale_colour_manual(values = my_colors)) 

ggsave(paste0(results_wd, "/glmm_results/plot_random_intercepts_CLC_facets.png"),
       plot = my_plot_1)
```


## Run glmm for breeding status

```{r}
## Define breeding status of each individual
unique(my_glmm_data$id)

## assigned breeding status
breed_status <- data.frame(
  id = c("WF5", "WR4", "WF3", "WR1", "FT10", "WR6", "FT6", "FT5", "ID3", "ID1", "MT2", 
         "IDp1", "FT4", "MT4", "FT3", "FT2", "MT3", "FT8", "FT7", "FT9", "MT5"), 
  status = as.factor(c("subadult", "breeder", "subadult", "subadult", "subadult", 
                       "breeder", "subadult", "subadult", "breeder", "subadult", 
                       "breeder", "breeder", "subadult", "breeder", "breeder", 
                       "subadult", "subadult", "breeder", "breeder", "breeder", "breeder"))
  )
breed_status

my_glmm_data_breed <- left_join(my_glmm_data, breed_status, by ="id")
summary(my_glmm_data_breed)
str(my_glmm_data_breed)
my_glmm_data_breed$id[is.na(my_glmm_data_breed$status)]

# Run glmm with breeding status 

glmm_status <- glmer(point_case  ~ status * CLC2012 +
                       status * (scale(HFP) + 
                       scale(Pop_den) + 
                       scale(Dist_settl) + 
                       scale(Dist_roads)) +
                   CLC2012 * 
                    (scale(HFP) + 
                       scale(Pop_den) + 
                       scale(Dist_settl) + 
                       scale(Dist_roads)) + 
                    (1|id), 
                  family = binomial(), 
                  weights = weighting, 
                  data = my_glmm_data_breed, 
                  verbose = FALSE, 
                  nAGQ = 0, 
                  control = glmerControl(optimizer = "nloptwrap"),
                  na.action = na.fail
                  )

summary(glmm_status)
```


## Plot individual effects - breeding

```{r}
pr <- ggpredict(glmm_status, terms = c("CLC2012", "id"), type = "re")

## Colors for IDs
my_colors <- viridis(18)

## Colors for status
breed_status <- breed_status %>% 
  mutate(col = case_when(
    status == "subadult" ~ "green3",
    status == "breeder" ~ "darkorange"
  ))

status_col <- breed_status$col

###########
table_pr <- cbind.data.frame(x = pr$x, predicted = pr$predicted, 
                             std.error = pr$std.error, 
                             conf.low = pr$conf.low, 
                             conf.high = pr$conf.high, 
                             group = pr$group)

plot_2 <- table_pr %>% 
  filter(x != 101) %>%  # removed due to excesive variance for the plot
  filter(x != 108) %>%
ggplot(aes(x = x, y = predicted, colour = group)) +
  # geom_jitter() +
  geom_point(position=position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), 
                position=position_dodge(width=0.5)) +
  scale_colour_manual(values = status_col,
                      name = "ID") +
  ylab("Predicted probability") +
  xlab("CLC2012") +
  ggtitle(NULL) +
  coord_cartesian(xlim = c(1, 6), # This focuses the x-axis on the range of interest
                      clip = 'off') + 
  scale_colour_manual(values = status_col,
                    name = "ID") +
  theme(
    panel.background = element_blank(), 
    axis.text = element_text(colour  = "black", size = 12),
    axis.title = element_text(colour  = "black", face = "bold", size = 14),
    axis.line.y = element_line(colour  = "black", size = 0.5), 
    axis.line.x = element_line(colour  = "black", size = 0.5), 
    legend.position = c(0.875, 0.57), 
    legend.key.height = unit(1,"line"),
    legend.background = element_rect(fill = "white")
  )+
  # annotate("rect", xmin = 5.5, xmax = 6.3, 
  #          ymin = -0.0, ymax = 0.13, 
  #          fill = "white", 
  #          colour = "black") +
  
  annotate("text", label = "breeder \nsubadult", x = 5.8, y = 0.025, hjust = 0, 
           vjust = 0) +
  
  annotate("text", label = "Breeding Status", x = 5.62, y = 0.12, hjust = 0, 
           vjust = 0) +
  annotate("point", colour = "darkorange", 
           x = 5.65, y = 0.035, size = 3) +
  annotate("point", colour = "green3", 
           x = 5.65, y = 0.08, size = 3)
plot_2


ggsave(plot = plot_2, 
       filename = paste0(results_wd, "/glmm_results/plot_random_intercepts_CLC_breeding_2.png"), 
       dpi = 600)
```





#---------------------------------
# MAXENT Telemetry model

we use data **before 2018**
- presences: telemetry data filtered by day and grid
- background: random points (10x presences) selected in bias raster with 
  prob 0.99 in 100% MCPs and 0.01 outside, filtered by grid
- environmental variables extracted at the point location
- Data divide into train (80%) and test (20%) sets


```{r prepare workspace}
rm(list = ls())

source("./Rscripts/source_file_packages.R")
source("./Rscripts/source_file_functions.R")

workDir <- getwd()
dataproc_wd <- paste0(workDir, "/output/data_proc")
geoproc_wd <- paste0(workDir, "/output/geo_proc")
results_wd <- paste0(workDir, "/output/results")
```

```{r Load data}
# environmental rasters
env_germany <- stack(paste0(geoproc_wd, "/stack_env_rasters_germany_3035_AP.tif"))
names(env_germany) <- c("CLC2012", "Pop_den", "HFP", "Dist_settl", "Dist_roads") 

# Load observations with env data
pres_gps_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_pres_telemetry.gpkg")) %>% 
  st_transform(crs = 3035)  
  
# Load background with env data
bg_mcp_maxent_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_bg_mcp_maxent.gpkg")) %>% 
  st_transform(crs = 3035)

# put both dataset together and select train and test data
pres_gps_envcov <- pres_gps_envcov_sf %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(point_case, type, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

bg_mcp_maxent_envcov <- bg_mcp_maxent_envcov_sf %>%
  mutate(point_case = 0) %>% 
  dplyr::select(point_case, type, CLC2012, Pop_den, Dist_settl, Dist_roads, HFP) 

all_mcp_maxent_envcov_sf <- rbind(pres_gps_envcov, bg_mcp_maxent_envcov) 
summary(all_mcp_maxent_envcov_sf)
```

Run mcp maxent model
```{r}
obs_mcp_train_df <- all_mcp_maxent_envcov_sf %>% 
  filter(type == "train") %>%
  filter(point_case == 1) %>% 
  st_coordinates()

bg_mcp_train_df <- all_mcp_maxent_envcov_sf %>% 
  filter(type == "train") %>% 
  filter(point_case == 0) %>% 
  st_coordinates()
  
nrow(obs_mcp_train_df) # 2591
nrow(bg_mcp_train_df) # 25920

maxent_mcp <- maxent(env_germany, 
                  obs_mcp_train_df,
                  a = bg_mcp_train_df, 
                  factors = c('CLC2012'),
                  path = paste0(results_wd, "/maxent_mcp_results"),
                  args = c("replicates=10", "outputformat=logistic", "writebackgroundpredictions"))

# saveRDS(maxent_mcp, paste0(results_wd, "/maxent_mcp_results/maxent_mcp_model.rds"))
```

### predict mcp maxent
```{r}
pred_maxent_mcp <- dismo::predict(maxent_mcp, env_germany, progress='text')

mean_pred_maxent_mcp <- mean(pred_maxent_mcp)

pred_maxent_mcp_mask <- mean_pred_maxent_mcp %>%
 mask(as(germany_3035, "Spatial"))

plot(pred_maxent_mcp_mask)
```


## Evaluate maxent mcp
```{r}
## AUC value
# evaluate model
obs_mcp_test_df <- all_mcp_maxent_envcov_sf %>% 
  filter(type == "test") %>%
  filter(point_case == 1) %>% 
  st_coordinates()

bg_mcp_test_df <- all_mcp_maxent_envcov_sf %>% 
  filter(type == "test") %>% 
  filter(point_case == 0) %>% 
  st_coordinates()

# as we run replicates, we need to evaluate all the models in the list
eval_list <- lapply(1:length(maxent_mcp@models), function(e){
eval_xm <- dismo::evaluate(p = obs_mcp_test_df, a = bg_mcp_test_df, model = maxent_mcp@models[[e]], x = env_germany); 
return(eval_xm)})

## get mean auc 
auc_list <- vector()
for (i in 1:length(eval_list)){
  auc_list[i] <- eval_list[[i]]@auc
}
mean(auc_list)

plot(eval_list[[1]],"ROC")


e <- eval_list[[1]]
threshold(e)
plot(e, 'ROC')
boxplot(e)

## get TSS value 
# TSS value (own function, source file)
maxent_mcp_tss <- get_maxent_tss(model_directory = paste0(results_wd, "/maxent_mcp_results"), 
                                 data.type = "test", n.replicates = 10)
maxent_mcp_tss
mean(maxent_mcp_tss$tss) 


## continuous Boyce index (library: ecospat)
# Requires the Habitat suitabilty predictions (below)
my_pred_raster <- list.files(paste0(results_wd ,"/maxent_mcp_results/"), 
                             pattern = c("pred_mean.+tif")) # filters for both patterns
pred_mean_maxent_mcp <- raster(paste0(results_wd ,"/maxent_mcp_results/", my_pred_raster))

obs_mcp_test_df

# with spatial data
boyce_maxent_mcp <- ecospat.boyce(fit = pred_mean_maxent_mcp, obs = obs_mcp_test_df, nclass = 0)
boyce_maxent_mcp$Spearman.cor
```


## Evaluate maxent mcp - test set 2, >= 2018
```{r}
## Load test 2 data
obs_mcp_test2_af2018 <- st_read(paste0(dataproc_wd, "/gps_points_eval_af2018_3035.gpkg"))
obs_mcp_test2_af2018_df <- st_coordinates(obs_mcp_test2_af2018)
nrow(obs_mcp_test2_af2018_df) # 601

bg_mcp_test2_af2018 <- st_read(paste0(dataproc_wd,"/bg_test2_af2018_maxent_mcp_3035_AP.gpkg"))
bg_mcp_test2_af2018_df <- st_coordinates(bg_mcp_test2_af2018)
nrow(bg_mcp_test2_af2018_df) # 6010

## AUC value
# evaluate model
# as we run replicates, we need to evaluate all the models in the list
eval_list_test2 <- lapply(1:length(maxent_mcp@models), function(e){
eval_xm <- dismo::evaluate(p = obs_mcp_test2_af2018_df, a = bg_mcp_test2_af2018_df, 
                           model = maxent_mcp@models[[e]], x = env_germany); 
return(eval_xm)})

# get mean auc 
auc_list_test2 <- vector()
for (i in 1:length(eval_list_test2)){
  auc_list_test2[i] <- eval_list_test2[[i]]@auc
}
mean(auc_list_test2)

plot(eval_list_test2[[1]],"ROC")


e <- eval_list_test2[[1]]
threshold(e)
plot(e, 'ROC')
boxplot(e)

## tss function
# TSS value (we get predictions for samples nad background 
# manually from prediction raster and coordinates)

# Requires the Habitat suitabilty predictions 
# get habitat values for test2 presences
samples_tmp <- raster::extract(pred_mean_maxent_mcp, as_Spatial(obs_mcp_test2_af2018), sp = TRUE)

# get habitat values for test2 backgrounds
background_tmp <- raster::extract(pred_mean_maxent_mcp, as_Spatial(bg_mcp_test2_af2018), sp = TRUE)

samples <- samples_tmp %>% 
  as.data.frame() %>% 
  dplyr::select(id, predict = grep(colnames(.), pattern= "pred_mean"), coords.x1, coords.x2)
  
background <- background_tmp %>% 
  as.data.frame() %>% 
  dplyr::select(predict = grep(colnames(.), pattern= "pred_mean"), coords.x1, coords.x2)

# get threshold: maxSSS averaged model
# Load thresholds
thresh_tmp <- read.csv(paste0(results_wd,"/maxent_mcp_results/maxentResults.csv"), header=TRUE)
#Select maximum logistic threshold values for test data 
threshold <- thresh_tmp[11,c(grep("Maximum.test.+logistic.threshold",names(thresh_tmp)))]
  
# get TSS
test2_mcp_maxent_tss <- calc_tss(samples, background, threshold)  
test2_mcp_maxent_tss


## continuous Boyce index (library: ecospat)
# Requires the Habitat suitabilty predictions 
boyce_test2_maxent_mcp <- ecospat.boyce(fit = pred_mean_maxent_mcp, obs = obs_mcp_test2_af2018_df, nclass = 0)
boyce_test2_maxent_mcp$Spearman.cor
# [1] 0.99
cor(boyce_test2_maxent_mcp$F.ratio, boyce_test2_maxent_mcp$HS, method = "spearman")
# [1] 0.989883
```



#----------------------------------------------------
# MAXENT Combined model

we use data **before 2018**
- presences: gps telemetry filtered by day and grid
- background: random points (10x presences) selected in bias raster with 
  prob 0.99 in 10km territory buffers and 0.01 outside, filtered by grid
- Data divide into train (80%) and test (20%) sets

```{r prepare workspace}
rm(list = ls())

source("./Rscripts/source_file_packages.R")
source("./Rscripts/source_file_functions.R")

workDir <- getwd()
dataproc_wd <- paste0(workDir, "/output/data_proc")
geoproc_wd <- paste0(workDir, "/output/geo_proc")
results_wd <- paste0(workDir, "/output/results")
```

Load data
```{r}
# environmental rasters
env_germany <- stack(paste0(geoproc_wd, "/stack_env_rasters_germany_3035_AP.tif"))
names(env_germany) <- c("CLC2012", "Pop_den", "HFP", "Dist_settl", "Dist_roads") 

# Load observations with env data
pres_gps_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_pres_telemetry.gpkg")) %>% 
  st_transform(crs = 3035)  

# Select presences train and test data
pres_gps_train <- pres_gps_envcov_sf %>% 
  filter(type == "train") %>% 
  st_coordinates()

pres_gps_test <- pres_gps_envcov_sf %>% 
  filter(type == "test") %>% 
  st_coordinates()

nrow(pres_gps_train) # [1] 2591
nrow(pres_gps_test) # [1] 649


# Load background
bg_train_maxent_comb_grid <- st_read(paste0(dataproc_wd,"/bg_train_bf2018_maxent_comb_3035_AP.gpkg"))
bg_test_maxent_comb_grid <- st_read(paste0(dataproc_wd,"/bg_test_bf2018_maxent_comb_3035_AP.gpkg"))

bg_comb_train <- bg_train_maxent_comb_grid %>% 
  st_coordinates()

bg_comb_test <- bg_test_maxent_comb_grid %>% 
  st_coordinates()

nrow(bg_comb_train) 
nrow(bg_comb_test) 
```

Run combined maxent model
```{r}
maxent_comb <- maxent(env_germany, 
                  pres_gps_train,
                  a = bg_comb_train, 
                  factors = c('CLC2012'),
                  path = paste0(results_wd, "/maxent_combined_results"),
                  args = c("replicates=10", "outputformat=logistic", "writebackgroundpredictions"))

# saveRDS(maxent_comb, paste0(results_wd, "/maxent_combined_results/maxent_combined_model.rds"))
```

#### predict combined maxent
```{r}
pred_maxent_comb <- dismo::predict(maxent_comb, env_germany, progress='text')

mean_pred_maxent_comb <- mean(pred_maxent_comb)

pred_maxent_comb_mask <- mean_pred_maxent_comb %>%
 mask(as(germany_3035, "Spatial"))

plot(pred_maxent_comb_mask)
```

## Evaluate maxent combined

```{r}
## AUC value
# as we run replicates, we need to evaluate all the models in the list
eval_list <- lapply(1:length(maxent_comb@models), function(e){
eval_xm <- dismo::evaluate(p = pres_gps_test, a = bg_comb_test, model = maxent_comb@models[[e]], x = env_germany); 
return(eval_xm)})

# get mean auc 
auc_list <- vector()
for (i in 1:length(eval_list)){
  auc_list[i] <- eval_list[[i]]@auc
}

mean(auc_list)

plot(eval_list[[1]],"ROC")

e <- eval_list[[1]]
threshold(e)
plot(e, 'ROC')
boxplot(e)

## TSS value (own function, source file)
maxent_comb_tss <- get_maxent_tss(model_directory = paste0(results_wd, "/maxent_combined_results"), 
                                 data.type = "test", n.replicates = 10)
maxent_comb_tss
mean(maxent_comb_tss$tss)
# [1] 

## continuous Boyce index (library: ecospat)
# Requires the Habitat suitabilty predictions 
my_pred_raster <- list.files(paste0(results_wd ,"/maxent_combined_results/"), 
                             pattern = c("pred_mean.+tif")) # filters for both patterns
pred_mean_maxent_comb <- raster(paste0(results_wd ,"/maxent_combined_results/", my_pred_raster))

pres_gps_test

# with spatial data
boyce_maxent_comb <- ecospat.boyce(fit = pred_mean_maxent_comb, obs = pres_gps_test, nclass = 0) # NA in obs might give errors
boyce_maxent_comb$Spearman.cor
```

## Evaluate maxent combined - test2, >= 2018
```{r}
## Load test 2 data
pres_test2_af2018_comb_maxent <- st_read(paste0(dataproc_wd,"/gps_points_eval_af2018_3035.gpkg"))
obs_comb_test2_af2018_df <- st_coordinates(pres_test2_af2018_comb_maxent)
nrow(obs_comb_test2_af2018_df) #[1] 601

bg_test2_maxent_comb <- st_read(paste0(dataproc_wd,"/bg_test2_af2018_maxent_comb_3035_AP.gpkg")) %>% 
   st_transform(crs = 3035) 
bg_comb_test2_af2018_df <- st_coordinates(bg_test2_maxent_comb)
nrow(bg_comb_test2_af2018_df) # 6009

## AUC value
# evaluate model
# as we run replicates, we need to evaluate all the models in the list
eval_list_comb_test2 <- lapply(1:length(maxent_comb@models), function(e){
eval_xm <- dismo::evaluate(p = obs_comb_test2_af2018_df, a = bg_comb_test2_af2018_df, 
                           model = maxent_comb@models[[e]], x = env_germany); 
return(eval_xm)})

# get mean auc 
auc_list_comb_test2 <- vector()
for (i in 1:length(eval_list_comb_test2)){
  auc_list_comb_test2[i] <- eval_list_comb_test2[[i]]@auc
}
mean(auc_list_comb_test2)

plot(eval_list_comb_test2[[1]],"ROC")


## tss function
samples_comb2_tmp <- raster::extract(pred_mean_maxent_comb, as_Spatial(pres_test2_af2018_comb_maxent), sp = TRUE)

# get habitat values for test2 backgrounds
background_comb2_tmp <- raster::extract(pred_mean_maxent_comb, as_Spatial(bg_test2_maxent_comb), sp = TRUE)

samples <- samples_comb2_tmp %>% 
  as.data.frame() %>% 
  dplyr::select(predict = grep(colnames(.), pattern= "pred_mean"), coords.x1, coords.x2)
  
background <- background_comb2_tmp %>% 
  as.data.frame() %>% 
  dplyr::select(predict = grep(colnames(.), pattern= "pred_mean"), coords.x1, coords.x2)

# get threshold: maxSSS averaged model
# Load thresholds
thresh_tmp <- read.csv(paste0(results_wd,"/maxent_combined_results/maxentResults.csv"), header=TRUE)
#Select maximum logistic threshold values for test data 
threshold <- thresh_tmp[11,c(grep("Maximum.test.+logistic.threshold",names(thresh_tmp)))]
  
# get TSS
test2_comb_maxent_tss <- calc_tss(samples, background, threshold)  
test2_comb_maxent_tss


## continuous Boyce index (library: ecospat)
# Requires the Habitat suitabilty predictions 

# with spatial data
boyce_test2_maxent_comb <- ecospat.boyce(fit = pred_mean_maxent_comb, obs = obs_comb_test2_af2018_df, nclass = 0)
boyce_test2_maxent_comb$Spearman.cor
```


#---------------------------------
# Ensemble Telemetry model

we use data **before 2018**
- presences: telemetry data filtered by day and grid
- background: random points (10x presences) selected in bias raster with 
  prob 0.99 in 100% MCPs and 0.01 outside, filtered by grid
- environmental variables extracted at the point location
- Data divide into train (80%) and test (20%) sets

We use the *background maxent* data as they represent the background points for germany 
in relation to the observed telemetry points and have been already filtered to keep only
one observation per grid


```{r workspace}
rm(list = ls())

source("./Rscripts/source_file_functions.R")

library(terra)
library(biomod2)
library(dplyr)
library(sf)
library(ecospat)

workDir <- getwd()
dataproc_wd <- paste0(workDir, "/output/data_proc")
geoproc_wd <- paste0(workDir, "/output/geo_proc")
results_wd <- paste0(workDir, "/output/results")
```

### Prepare data
```{r load data}
# Load observations with env data bf 2018
tmp_pres_gps_bf2018 <- st_read(paste0(dataproc_wd, "/gps_points_bf2018_3035.gpkg")) %>% 
  st_transform(crs = 3035)  
  
# Load background bf 2018
tmp_bg_gps_bf2018 <- st_read(paste0(dataproc_wd,"/bg_mcp_bf2018_3035_AP.gpkg"))


# put presences and background data together in one file
pres_gps_bf2018 <- tmp_pres_gps_bf2018 %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(point_case) 

bg_mcp_bf2018 <- tmp_bg_gps_bf2018 %>%
  mutate(point_case = 0) %>% 
  dplyr::select(point_case) 

mcp_points_bf2018 <- rbind(pres_gps_bf2018, bg_mcp_bf2018) 
head(mcp_points_bf2018)

# Data for validation
pres_test2_mcp_sf <- st_read(paste0(dataproc_wd, "/gps_points_af2018_3035.gpkg"), crs = 3035)
bg_test2_mcp_sf <- st_read(paste0(dataproc_wd, "/bg_test2_af2018_maxent_mcp_3035_AP.gpkg"), crs = 3035)

# put presences and background data together 
tmp_pres_af2018 <- pres_test2_mcp_sf %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(point_case) 

tmp_bg_mcp_af2018 <- bg_test2_mcp_sf %>%
  mutate(point_case = 0) %>% 
  dplyr::select(point_case) 

mcp_points_af2018 <- rbind(tmp_pres_af2018, tmp_bg_mcp_af2018) 
head(mcp_points_af2018)
```

```{r get points in spatvector format}
mcp_points_bf2018_spv <- vect(mcp_points_bf2018)
head(values(mcp_points_bf2018_spv))
tail(values(mcp_points_bf2018_spv))

mcp_points_af2018_spv <- vect(mcp_points_af2018)
```

### prepare biomod object
```{r biomod object}
## Parameterize model options
# For maxent, we need to add some options to the models. 
# Important, the directory where to find java/maxent. 
myBiomodOptions <- BIOMOD_ModelingOptions(
  MAXENT = list( maximumiterations = 5000,
                 responsecurves=TRUE,
                 jacknife=TRUE,
                 visible = FALSE,
                 directory="/output/results_models/",
                 linear = TRUE, 
                 quadratic = TRUE,
                 product = TRUE,
                 threshold = FALSE,
                 hinge = TRUE,
                 lq2lqptthreshold = 80,
                 l2lqthreshold = 10,
                 hingethreshold = 15,
                 beta_threshold = -1,
                 beta_categorical = -1,
                 beta_lqp = -1,
                 beta_hinge = -1,
                 defaultprevalence = 0.5),
  GLM = list(family = "binomial"),
  GAM = list( k = 5))

## preapre data
ensemble_mcp_dat <- BIOMOD_FormatingData(resp.var = mcp_points_bf2018_spv,
                                     expl.var = env_germany_fct,
                                     resp.name = "wolf_mcp_telemetry",
                                     eval.resp.var = mcp_points_af2018_spv, # evaluation set
                                     filter.raster = TRUE) # remove points from the same grid
ensemble_mcp_dat
# plot(ensemble_mcp_dat)
                            
myBiomodOptions
```

### run biomod models
```{r run biomod}
## models to run
mcp_mod_out <- BIOMOD_Modeling(bm.format = ensemble_mcp_dat,
                               bm.options = myBiomodOptions,
                               models =c('GLM','GAM','GBM', 'MARS', 'ANN','RF','MAXENT'),
                               modeling.id = 'AllModels', 
                               nb.rep = 10, # three repetitions to make it faster
                               data.split.perc = 80, # 80% training
                               var.import = 10, 
                               metric.eval = c("TSS", "ROC"),
                               nb.cpu = 5, 
                               do.full.models = FALSE,
                               save.output = TRUE) # number of cores

# saveRDS(mcp_mod_out, paste0(results_wd, "/ensemble_mcp_results/ensemble_mcp_models.rds"))

## check output
mcp_mod_out
str(mcp_mod_out)
mcp_mod_out@models.computed

get_evaluations(mcp_mod_out)
```

### Create ensemble model
```{r}
### Building ensemble-models all models 
mcp_ensemblemod <- BIOMOD_EnsembleModeling(bm.mod = mcp_mod_out,
                                      models.chosen = 'all',
                                      em.by = 'all',
                                      em.algo = c('EMwmean'),
                                      metric.select = c('ROC'),
                                      # metric.select.thresh = c(0.7),
                                      metric.eval = c('TSS', 'ROC'),
                                      var.import = 10,
                                      EMci.alpha = 0.05,
                                      EMwmean.decay = 'proportional', 
                                      nb.cpu = 5)
mcp_ensemblemod
# saveRDS(mcp_ensemblemod, paste0(results_wd, "/ensemble_mcp_results/mcp_ensemble_mod.rds"))
```


### Project ensemble model
```{r project mcp ensemble}
str(mcp_ensemblemod)

env_germany <- rast(paste0(geoproc_wd, "/stack_env_rasters_germany_3035_AP.tif"))
names(env_germany) <- c("CLC2012", "Pop_den", "HFP", "Dist_settl", "Dist_roads") 

env_germany_fct <- env_germany
env_germany_fct$CLC2012 <- as.factor(env_germany_fct$CLC2012)

# Project ensemble models (building single projections)
mcp_BiomodEMProj <- BIOMOD_EnsembleForecasting(bm.em = mcp_ensemblemod,
                                             proj.name = 'mcp_ensemble',
                                             new.env = env_germany_fct)

mcp_BiomodEMProj
plot(mcp_BiomodEMProj)
# saveRDS(mcp_BiomodEMProj, paste0(results_wd, "/ensemble_mcp_results/mcp_ensemble_proj.rds"))
```

```{r extract raster from ensemble projection}
mcp_projEnsemble <- get_predictions(mcp_BiomodEMProj)
names(mcp_projEnsemble) <- "habitat_suitability"

plot(mcp_projEnsemble)

# terra::writeRaster(mcp_projEnsemble,
#             filename = paste0(results_wd, "/ensemble_mcp_results/mcp_ensemble_weightedmean_projection_3035.tif"),
#             overwrite = T)
```


## evaluate model - test 1

```{r get AUC, TSS and boyce - test data}
names(pred_mcp) <- "habitat_suitability"

## AUC values
mcp_points_bf2018_spv

ens_values <- terra::extract(pred_mcp, mcp_points_bf2018_spv)
head(ens_values)

pres_values <- cbind(mcp_points_bf2018, ens_values) %>% 
  filter(point_case == 1) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry() 

pres_vector <- pres_values$habitat_suitability

bg_values <- cbind(mcp_points_bf2018, ens_values) %>% 
  filter(point_case == 0) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry()

bg_vector <- bg_values$habitat_suitability

eval_xm <- dismo::evaluate(p = pres_vector, a = bg_vector)

## TSS values
# Load thresholds
threshold <- get_evaluations(mcp_ensemblemod)$cutoff[1]  

# samples
pres_values_tss <- cbind(mcp_points_bf2018, ens_values) %>% 
  filter(point_case == 1) %>% 
  mutate(predict = habitat_suitability)

bg_values_tss <- cbind(mcp_points_bf2018, ens_values) %>% 
  filter(point_case == 0) %>% 
  mutate(predict = habitat_suitability)
  
# get TSS
mcp_ensemble_tss <- calc_tss(samples = pres_values_tss, background = bg_values_tss, threshold)  
mcp_ensemble_tss

## continuous Boyce index (library: ecospat)

# with spatial data
pred_hs <- values(pred_mcp)
pred_hs <- pred_hs[!is.na(pred_hs)]

boyce_test_mcp_ensemble <- ecospat.boyce(fit = pred_hs, obs = pres_vector, nclass = 0)
cor(boyce_test_mcp_ensemble$F.ratio, boyce_test_mcp_ensemble$HS, method = "spearman")
```


## evaluate model - test 2

```{r get AUC, TSS and boyce - test2 data}
## AUC values
mcp_points_af2018_spv

ens_values2 <- terra::extract(pred_mcp, mcp_points_af2018_spv)
head(ens_values2)

pres_values <- cbind(mcp_points_af2018, ens_values2) %>% 
  filter(point_case == 1) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry() 

pres_vector <- pres_values$habitat_suitability[!is.na(pres_values$habitat_suitability)]

bg_values <- cbind(mcp_points_af2018, ens_values2) %>% 
  filter(point_case == 0) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry()

bg_vector <- bg_values$habitat_suitability

eval_xm <- dismo::evaluate(p = pres_vector, a = bg_vector)

## TSS values
# Load thresholds
threshold <- get_evaluations(mcp_ensemblemod)$cutoff[1]  

# samples
pres_values_tss <- cbind(mcp_points_af2018, ens_values2) %>% 
  filter(point_case == 1) %>% 
  mutate(predict = habitat_suitability)

bg_values_tss <- cbind(mcp_points_af2018, ens_values2) %>% 
  filter(point_case == 0) %>% 
  mutate(predict = habitat_suitability)
  
# get TSS
mcp_ensemble_tss2 <- calc_tss(samples = pres_values_tss, background = bg_values_tss, threshold)  
mcp_ensemble_tss2

## continuous Boyce index (library: ecospat)

# with spatial data
pred_hs <- values(comb_ensemble)
pred_hs <- pred_hs[!is.na(pred_hs)]

boyce_test_comb_ensemble <- ecospat.boyce(fit = pred_hs, obs = pres_vector, nclass = 0)
cor(boyce_test_comb_ensemble$F.ratio, boyce_test_comb_ensemble$HS, method = "spearman")
```


#---------------------------------
# ENSEMBLE Combined

we use data **before 2018**
- presences: gps telemetry filtered by day and grid
- background: random points (10x presences) selected in bias raster with 
  prob 0.99 in 10km territory buffers and 0.01 outside, filtered by grid
- Data divide into train (80%) and test (20%) sets

Now we are going to use the points as spatialpointdataframe, and the environmental variables will be extracted from the rasters

```{r workspace}
rm(list = ls())

source("./Rscripts/source_file_functions.R")

library(terra)
library(biomod2)
library(dplyr)
library(sf)
library(ecospat)

workDir <- getwd()
dataproc_wd <- paste0(workDir, "/output/data_proc")
geoproc_wd <- paste0(workDir, "/output/geo_proc")
results_wd <- paste0(workDir, "/output/results")
```

# Load environmental variables
```{r}
## spatial data
# environmental rasters
env_germany <- rast(paste0(geoproc_wd, "/stack_env_rasters_germany_3035_AP.tif"))
names(env_germany) <- c("CLC2012", "Pop_den", "HFP", "Dist_settl", "Dist_roads") 

env_germany_fct <- env_germany
env_germany_fct$CLC2012 <- as.factor(env_germany_fct$CLC2012)
```


# ENSEMBLE Combined data

we use data **before 2018**
- presences: gps telemetry filtered by day and grid
- background: random points (10x presences) selected in bias raster with 
  prob 0.99 in 10km territory buffers and 0.01 outside, filtered by grid
- Data divide into train (80%) and test (20%) sets


### Load data
```{r}
## Points BEFORE 2018
# Load observations with env data
pres_gps_envcov_sf <- st_read(paste0(dataproc_wd, "/envcov_pres_telemetry.gpkg")) %>% 
  st_transform(crs = 3035)  

# Select presences train and test data
pres_comb_bf2018 <- pres_gps_envcov_sf %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(point_case, type)


# Load background
bg_train_maxent_comb_grid <- st_read(paste0(dataproc_wd,"/bg_train_bf2018_maxent_comb_3035_AP.gpkg"))
bg_test_maxent_comb_grid <- st_read(paste0(dataproc_wd,"/bg_test_bf2018_maxent_comb_3035_AP.gpkg"))

bg_comb_bf2018 <- bg_train_maxent_comb_grid %>% 
  mutate(point_case = 0, type = "train") %>% 
  rbind(bg_test_maxent_comb_grid %>% mutate(point_case = 0, type = "test"))

bg_comb_bf2018 %>% 
  st_drop_geometry() %>% 
  group_by(type) %>% 
  summarise(n = n())

## Points AFTER 2018 - TEST2
pres_test2_tmp <- st_read(paste0(dataproc_wd,"/gps_points_eval_af2018_3035.gpkg"))

pres_test2_af2018_comb <- pres_test2_tmp %>% 
  mutate(point_case = 1) %>% 
  dplyr::select(point_case)

bg_test2_tmp <- st_read(paste0(dataproc_wd,"/bg_test2_af2018_maxent_comb_3035_AP.gpkg")) 
     
bg_test2_af2018_comb <- bg_test2_tmp %>% 
  mutate(point_case = 0) %>% 
  dplyr::select(point_case)
```

```{r get points in spatvector format}
## BEFORE 2018
comb_points_bf2018 <- rbind(pres_comb_bf2018, bg_comb_bf2018) %>% 
  dplyr::select(point_case)

comb_points_bf2018_spv <- vect(comb_points_bf2018)
head(values(comb_points_bf2018_spv))
tail(values(comb_points_bf2018_spv))

comb_points_af2018_spv <- vect(comb_points_bf2018)

comb_points_bf2018_spv %>% 
  as.data.frame() %>% 
  group_by(point_case) %>% 
  summarise(n = n())


## AFTER 2018
comb_points_af2018 <- rbind(pres_test2_af2018_comb, bg_test2_af2018_comb)

comb_points_af2018_spv <- vect(comb_points_af2018)

comb_points_af2018_spv %>% 
  as.data.frame() %>% 
  group_by(point_case) %>% 
  summarise(n = n())
```

### prepare biomod object
```{r biomod object}
## Parameterize model options
# For maxent, we need to add some options to the models. 
# Important, the directory where to find java/maxent. 
myBiomodOptions <- BIOMOD_ModelingOptions(
  MAXENT = list( maximumiterations = 5000,
                 responsecurves=TRUE,
                 jacknife=TRUE,
                 visible = FALSE,
                 directory="/output/results_models/",
                 linear = TRUE, 
                 quadratic = TRUE,
                 product = TRUE,
                 threshold = FALSE,
                 hinge = TRUE,
                 lq2lqptthreshold = 80,
                 l2lqthreshold = 10,
                 hingethreshold = 15,
                 beta_threshold = -1,
                 beta_categorical = -1,
                 beta_lqp = -1,
                 beta_hinge = -1,
                 defaultprevalence = 0.5),
  GLM = list(family = "binomial"),
  GAM = list( k = 5))


## preapre data
ensemble_comb_dat <- BIOMOD_FormatingData(resp.var = comb_points_bf2018_spv,
                                     expl.var = env_germany_fct,
                                     resp.name = "wolf_comb",
                                     eval.resp.var = comb_points_af2018_spv, # evaluation set
                                     filter.raster = TRUE) # remove points from the same grid
ensemble_comb_dat

myBiomodOptions
```

### run biomod models
```{r run biomod}
## models to run
comb_mod_out <- BIOMOD_Modeling(bm.format = ensemble_comb_dat,
                               bm.options = myBiomodOptions,
                               models =c('GLM','GAM','GBM', 'MARS', 'ANN','RF','MAXENT'),
                               modeling.id = 'AllModels', 
                               nb.rep = 10, 
                               data.split.perc = 80, # 80% training
                               var.import = 10, 
                               metric.eval = c("TSS", "ROC"),
                               nb.cpu = 5, 
                               do.full.models = FALSE,
                               save.output = TRUE) # number of cores

# saveRDS(comb_mod_out, paste0(results_wd, "/ensemble_comb_results/ensemble_comb_models.rds"))

## check output
comb_mod_out
str(comb_mod_out)
comb_mod_out@models.computed

get_evaluations(comb_mod_out)
```

### Create ensemble model
```{r}
### Building ensemble-models all models 
comb_ensemblemod <- BIOMOD_EnsembleModeling(bm.mod = comb_mod_out,
                                      models.chosen = 'all',
                                      em.by = 'all',
                                      em.algo = c('EMwmean'),
                                      metric.select = c('ROC'),
                                      # metric.select.thresh = c(0.7),
                                      metric.eval = c('TSS', 'ROC'),
                                      var.import = 10,
                                      EMci.alpha = 0.05,
                                      EMwmean.decay = 'proportional', 
                                      nb.cpu = 5)
comb_ensemblemod
# saveRDS(comb_ensemblemod, paste0(results_wd, "/ensemble_comb_results/comb_ensemble_mod.rds"))
```

### Project ensemble model
```{r project mcp ensemble}
str(comb_ensemblemod)

comb_BiomodEMProj <- BIOMOD_EnsembleForecasting(bm.em = comb_ensemblemod,
                                             proj.name = 'comb_ensemble',
                                             new.env = env_germany_fct)

comb_BiomodEMProj
plot(comb_BiomodEMProj)
# saveRDS(comb_BiomodEMProj, paste0(results_wd, "/ensemble_comb_results/comb_ensemble_proj.rds"))

```

```{r extract raster from ensemble projection}
pred_comb <- get_predictions(comb_BiomodEMProj)
names(pred_comb) <- "habitat_suitability"

plot(pred_comb)

# terra::writeRaster(pred_comb,
#             filename = paste0(results_wd, "/ensemble_comb_results/raster_comb_ensemble_3035_100m.tif"),
#             overwrite = T)
```


## evaluate model - test 1

```{r get AUC, TSS and boyce - test data}

## AUC values
comb_points_bf2018_spv

ens_values <- terra::extract(pred_comb, comb_points_bf2018_spv)
head(ens_values)

pres_values <- cbind(comb_points_bf2018, ens_values) %>% 
  filter(point_case == 1) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry() 

pres_vector <- pres_values$habitat_suitability

bg_values <- cbind(comb_points_bf2018, ens_values) %>% 
  filter(point_case == 0) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry()

bg_vector <- bg_values$habitat_suitability

eval_xm <- dismo::evaluate(p = pres_vector, a = bg_vector)


## TSS values
# Load thresholds
threshold <- get_evaluations(comb_ensemblemod)$cutoff[1]  

# samples
pres_values_tss <- cbind(comb_points_bf2018, ens_values) %>% 
  filter(point_case == 1) %>% 
  mutate(predict = habitat_suitability)


bg_values_tss <- cbind(comb_points_bf2018, ens_values) %>% 
  filter(point_case == 0) %>% 
  mutate(predict = habitat_suitability)
  
# get TSS
comb_ensemble_tss <- calc_tss(samples = pres_values_tss, background = bg_values_tss, threshold)  
comb_ensemble_tss


## continuous Boyce index (library: ecospat)

# with spatial data
pred_hs <- values(pred_comb)
pred_hs <- pred_hs[!is.na(pred_hs)]

boyce_test_comb_ensemble <- ecospat.boyce(fit = pred_hs, obs = pres_vector, nclass = 0)
cor(boyce_test_comb_ensemble$F.ratio, boyce_test_comb_ensemble$HS, method = "spearman")
```


## evaluate model - test 2

```{r get AUC, TSS and boyce - test2 data}
## AUC values
comb_points_af2018_spv

ens_values2 <- terra::extract(pred_comb, comb_points_af2018_spv)
head(ens_values2)

pres_values <- cbind(comb_points_af2018, ens_values2) %>% 
  filter(point_case == 1) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry() 

pres_vector <- pres_values$habitat_suitability[!is.na(pres_values$habitat_suitability)]

bg_values <- cbind(comb_points_af2018, ens_values2) %>% 
  filter(point_case == 0) %>% 
  dplyr::select(habitat_suitability) %>% 
  st_drop_geometry()

bg_vector <- bg_values$habitat_suitability

eval_xm <- dismo::evaluate(p = pres_vector, a = bg_vector)

## TSS values
# Load thresholds
threshold <- get_evaluations(comb_ensemblemod)$cutoff[1]  

# samples
pres_values_tss <- cbind(comb_points_af2018, ens_values2) %>% 
  filter(point_case == 1) %>% 
  mutate(predict = habitat_suitability)

bg_values_tss <- cbind(comb_points_af2018, ens_values2) %>% 
  filter(point_case == 0) %>% 
  mutate(predict = habitat_suitability)
  
# get TSS
comb_ensemble_tss2 <- calc_tss(samples = pres_values_tss, background = bg_values_tss, threshold)  
comb_ensemble_tss2


## continuous Boyce index (library: ecospat)

# with spatial data
pred_hs <- values(comb_ensemble)
pred_hs <- pred_hs[!is.na(pred_hs)]

boyce_test_comb_ensemble <- ecospat.boyce(fit = pred_hs, obs = pres_vector, nclass = 0)
cor(boyce_test_comb_ensemble$F.ratio, boyce_test_comb_ensemble$HS, method = "spearman")
```