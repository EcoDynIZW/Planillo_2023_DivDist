####--------------------------------------------####
## FUNCTIONS
####--------------------------------------------####

## Mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}


## TSS test

# tss function
calc_tss <- function(samples, background, threshold){
  sensitivity <-sum( samples$predict >= threshold, na.rm = TRUE) /nrow( samples )
  specificity <-sum( background$predict < threshold, na.rm = TRUE) /nrow( background )
  sensitivity + specificity - 1
}

# maxent_out <- paste0(results_wd, "/maxent_mcp_results_test/")

# TSS for maxent replicates
get_maxent_tss <- function(model_directory, data.type = "test", n.replicates){
  ## Extrac MaxSSS threshold values from the maxent outputs
  # Load thresholds
  thresh_tmp <- read.csv(paste0(model_directory,"/maxentResults.csv"), header=TRUE)
  #Select only logistic threshold values and invert the table
  thresh_df <- thresh_tmp[,c(grep("Maximum.+logistic.threshold",names(thresh_tmp)))]
  thresh_df$run <- 1:nrow(thresh_df)
  thresh_df <-melt(thresh_df, id.vars=c("run"))
  thresh_df <- rename(thresh_df, threshold = variable)
  # Select the MaxSSS threshold
  # (Here, Maximum Test Sensitivity Plus Specificity; MaxSSS)
  #
  sub_thresh <- thresh_df[c(grep(paste0("Maximum.", data.type),thresh_df$threshold))[1:n.replicates], ] # ten values because the 11th is the average model
  sub_thresh <- data.frame(sub_thresh)
  
  ## Extract predictions from sample files
  # create empty vector
  s_samp_df <- list()
  # For-loop
  for (i in 1:n.replicates){
    #Read CSV file of maxent results (generated by maxent earlier)
    res_df <- read.csv(paste0(model_directory,"/species_", i-1, "_samplePredictions.csv"), header=TRUE)
    # remove training values
    res_df <- res_df[(res_df$Test.or.train == data.type),]
    #Select only logistic threshold values and invert the table
    # name here matches name in tss_calc function
    predict <- res_df[,c(grep("Logistic.prediction", names(res_df)))]
    # change to dataframe with column of number of run
    samp_df <- data.frame(run = i, predict)
    # Add to List
    s_samp_df[[i]] <- samp_df
  }
  samp_all <- do.call(rbind, s_samp_df)
  
  ## Extract predictions from background files
  # create empty vector
  s_bg_df <- list()
  # For-loop
  for (j in 1:n.replicates){
    #Read CSV file of maxent results (generated by maxent earlier)
    res_df <- read.csv(paste0(model_directory,"/species_", j-1, "_backgroundPredictions.csv"), header=TRUE)
    #Select only logistic prediction values
    # name here matches name in tss_calc function
    predict <- res_df[,c(grep("logistic", names(res_df)))]
    # Add a column to indicate corresponding run within the table
    bg_df <- data.frame(run = j, predict)
    # Add to List
    s_bg_df[[j]] <- bg_df
  }
  bg_all <- do.call(rbind, s_bg_df)
  
  ## Calculate TSS in a for-loop
  # empty list
  tss <- vector()
  
  # tss for-loop
  for (run in 1:n.replicates){
    # extract threshold by number in row
    threshold <- sub_thresh$value[run]
    # extract sample and background predictions by number of run
    samples <- samp_all[(samp_all$run==run),]
    background <- bg_all[(bg_all$run==paste0(run)),]
    # run tss function
    tss_run <- calc_tss(samples,background,threshold)
    # add to list
    tss[run] <- tss_run
  }
  
  final_data <- cbind.data.frame(sub_thresh, tss)
  return(final_data)
}

## get boyce index - modified


ecospat.boyce.2 <- function(fit, obs, nclass = 0, window.w = "default", res = 100, 
                          PEplot = TRUE, rm.duplicate = TRUE, method = 'spearman') {
  
  #### internal function calculating predicted-to-expected ratio for each class-interval
  boycei <- function(interval, obs, fit) {
    pi <- sum(as.numeric(obs >= interval[1] & obs <= interval[2])) / length(obs)
    ei <- sum(as.numeric(fit >= interval[1] & fit <= interval[2])) / length(fit)
    return(round(pi/ei,10))
  }
  
  if (inherits(fit,"RasterLayer")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- extract(fit, obs)
      ## added this to prevent errors due to NA values
      obs <- obs[!is.na(obs)]
    }
    fit <- getValues(fit)
    fit <- fit[!is.na(fit)]
  }
  
  if (inherits(fit,"SpatRaster")) {
    if (is.data.frame(obs) || is.matrix(obs)) {
      obs <- extract(fit, obs)
      ## added this to prevent errors due to NA values
      obs <- obs[!is.na(obs)]
    }
    fit <- values(fit)
    fit <- fit[!is.na(fit)]
  }
  
  mini <- min(fit,obs)
  maxi <- max(fit,obs)
  
  if(length(nclass)==1){
    if (nclass == 0) { #moving window
      if (window.w == "default") {window.w <- (max(fit) - min(fit))/10}
      vec.mov <- seq(from = mini, to = maxi - window.w, by = (maxi - mini - window.w)/res)
      vec.mov[res + 1] <- vec.mov[res + 1] + 1  #Trick to avoid error with closed interval in R
      interval <- cbind(vec.mov, vec.mov + window.w)
    } else{ #window based on nb of class
      vec.mov <- seq(from = mini, to = maxi, by = (maxi - mini)/nclass)
      interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
    }
  } else{ #user defined window
    vec.mov <- c(mini, sort(nclass[!nclass>maxi|nclass<mini]))
    interval <- cbind(vec.mov, c(vec.mov[-1], maxi))
  }
  
  f <- apply(interval, 1, boycei, obs, fit)
  to.keep <- which(f != "NaN")  # index to keep no NaN data
  f <- f[to.keep]
  if (length(f) < 2) {
    b <- NA  #at least two points are necessary to draw a correlation
  } else {
    r<-1:length(f)
    if(rm.duplicate == TRUE){
      r <- c(1:length(f))[f != c( f[-1],TRUE)]  #index to remove successive duplicates
    }
    b <- cor(f[r], vec.mov[to.keep][r], method = method)  # calculation of the correlation (i.e. Boyce index) after removing successive duplicated values
  }
  HS <- apply(interval, 1, sum)/2  # mean habitat suitability in the moving window
  if(length(nclass)==1 & nclass == 0) {
    HS[length(HS)] <- HS[length(HS)] - 1  #Correction of the 'trick' to deal with closed interval
  }
  HS <- HS[to.keep]  #exclude the NaN
  if (PEplot == TRUE) {
    plot(HS, f, xlab = "Habitat suitability", ylab = "Predicted/Expected ratio", col = "grey", cex = 0.75)
    points(HS[r], f[r], pch = 19, cex = 0.75)
  }
  return(list(F.ratio = f, cor = round(b, 3), HS = HS))
}
